{
    "docs": [
        {
            "location": "/",
            "text": "Tusk\n\n\n\n\n\n\n\n\n\n\n\n\nTusk is a yaml-based task runner. By creating a \ntusk.yml\n in the root of a\nrepository, Tusk becomes a custom command line tool with minimal configuration.\n\n\nFeatures\n\n\n\n\nCustomizable\n: Specify your own tasks and options with support for command-line\n  flags, environment variables, conditional logic, and more.\n\n\nExplorable\n: With help documentation generated dynamically and support for Bash\n  and Zsh tab completion available, all the help you need to get started in a\n  project is available straight from the command line.\n\n\nAccessible\n: Built for usability with a simple YAML configuration, familiar\n  syntax for passing options, Bash-like variable interpolation, and a colorful\n  terminal output.\n\n\nZero Dependencies\n: All you need is a single binary file to get started on\n  Linux, macOS, or Windows.\n\n\n\n\nGetting Started\n\n\nInstallation\n\n\nThe latest version can be installed from the \nreleases page\n.\n\n\nOn macOS, installation is also available through \nhomebrew\n:\n\n\nbrew install rliebz/tusk/tusk\n\n\n\n\n\nUsage\n\n\nCreate a \ntusk.yml\n file in the root of a project repository:\n\n\ntasks\n:\n\n  \ngreet\n:\n\n    \nusage\n:\n \nSay hello to someone\n\n    \noptions\n:\n\n      \nname\n:\n\n        \nusage\n:\n \nA person to say \"Hello\" to\n\n        \ndefault\n:\n \nWorld\n\n    \nrun\n:\n \necho \"Hello, ${name}!\"\n\n\n\n\n\n\nAs long as there is a \ntusk.yml\n file in the working or any parent directory,\ntasks can be run:\n\n\n$ tusk greet --name friend\nRunning: echo \"Hello, friend!\"\nHello, friend!\n\n\n\n\n\nHelp messages are dynamically generated based on the YAML configuration:\n\n\n$ tusk --help\ntusk - a task runner built with simplicity in mind\n\nUsage:\n   tusk [global options] <task> [task options]\n\nTasks:\n   greet  Say hello to someone\n\nGlobal Options:\n   -f, --file file  Set file to use as the config file\n   -h, --help       Show help and exit\n   ...\n\n\n\n\n\nIndividual tasks have help messages as well:\n\n\n$ tusk greet --help\ntusk greet - Say hello to someone\n\nUsage:\n   tusk greet [options]\n\nOptions:\n   --name value  A person to say \"Hello\" to\n\n\n\n\n\nFor more detailed examples, check out the project's own \ntusk.yml\n\nfile.\n\n\nContributing\n\n\nSet-up instructions for a development environment and contribution guidelines\ncan be found in \nCONTRIBUTING.md\n.",
            "title": "Getting Started"
        },
        {
            "location": "/#tusk",
            "text": "Tusk is a yaml-based task runner. By creating a  tusk.yml  in the root of a\nrepository, Tusk becomes a custom command line tool with minimal configuration.",
            "title": "Tusk"
        },
        {
            "location": "/#features",
            "text": "Customizable : Specify your own tasks and options with support for command-line\n  flags, environment variables, conditional logic, and more.  Explorable : With help documentation generated dynamically and support for Bash\n  and Zsh tab completion available, all the help you need to get started in a\n  project is available straight from the command line.  Accessible : Built for usability with a simple YAML configuration, familiar\n  syntax for passing options, Bash-like variable interpolation, and a colorful\n  terminal output.  Zero Dependencies : All you need is a single binary file to get started on\n  Linux, macOS, or Windows.",
            "title": "Features"
        },
        {
            "location": "/#getting-started",
            "text": "",
            "title": "Getting Started"
        },
        {
            "location": "/#installation",
            "text": "The latest version can be installed from the  releases page .  On macOS, installation is also available through  homebrew :  brew install rliebz/tusk/tusk",
            "title": "Installation"
        },
        {
            "location": "/#usage",
            "text": "Create a  tusk.yml  file in the root of a project repository:  tasks : \n   greet : \n     usage :   Say hello to someone \n     options : \n       name : \n         usage :   A person to say \"Hello\" to \n         default :   World \n     run :   echo \"Hello, ${name}!\"   As long as there is a  tusk.yml  file in the working or any parent directory,\ntasks can be run:  $ tusk greet --name friend\nRunning: echo \"Hello, friend!\"\nHello, friend!  Help messages are dynamically generated based on the YAML configuration:  $ tusk --help\ntusk - a task runner built with simplicity in mind\n\nUsage:\n   tusk [global options] <task> [task options]\n\nTasks:\n   greet  Say hello to someone\n\nGlobal Options:\n   -f, --file file  Set file to use as the config file\n   -h, --help       Show help and exit\n   ...  Individual tasks have help messages as well:  $ tusk greet --help\ntusk greet - Say hello to someone\n\nUsage:\n   tusk greet [options]\n\nOptions:\n   --name value  A person to say \"Hello\" to  For more detailed examples, check out the project's own  tusk.yml \nfile.",
            "title": "Usage"
        },
        {
            "location": "/#contributing",
            "text": "Set-up instructions for a development environment and contribution guidelines\ncan be found in  CONTRIBUTING.md .",
            "title": "Contributing"
        },
        {
            "location": "/spec/",
            "text": "The Spec\n\n\nTasks\n\n\nThe core of every \ntusk.yml\n file is a list of tasks. Tasks are declared at the\ntop level of the \ntusk.yml\n file and include a list of tasks.\n\n\nFor the following tasks:\n\n\ntasks\n:\n\n  \nhello\n:\n\n    \nrun\n:\n \necho \"Hello, world!\"\n\n  \ngoodbye\n:\n\n    \nrun\n:\n \necho \"Goodbye, world!\"\n\n\n\n\n\n\nThe commands can be run with no additional configuration:\n\n\n$ tusk hello\nRunning: echo \"Hello, world!\"\nHello, world!\n\n\n\n\n\nTasks can be documented with a one-line \nusage\n string and a slightly longer\n\ndescription\n. This information will be displayed in help messages:\n\n\ntasks\n:\n\n  \nhello\n:\n\n    \nusage\n:\n \nSay hello to the world\n\n    \ndescription\n:\n \n|\n\n      \nThis command will echo \"Hello, world!\" to the user. There's no\n\n      \nsurprises here.\n\n    \nrun\n:\n \necho \"Hello, world!\"\n\n  \ngoodbye\n:\n\n    \nrun\n:\n \necho \"Goodbye, world!\"\n\n\n\n\n\n\nRun\n\n\nThe behavior of a task is defined in its \nrun\n clause. A \nrun\n clause can be\nused for commands, sub-tasks, or setting environment variables. Although each\n\nrun\n item can only perform one of these actions, they can be run in succession\nto handle complex scenarios.\n\n\nCommand\n\n\nIn its simplest form, \nrun\n can be given a string or list of strings to be\nexecuted serially as shell commands:\n\n\ntasks\n:\n\n  \nhello\n:\n\n    \nrun\n:\n \necho \"Hello!\"\n\n\n\n\n\n\nThis is a shorthand syntax for the following:\n\n\ntasks\n:\n\n  \nhello\n:\n\n    \nrun\n:\n\n      \n-\n \ncommand\n:\n \necho \"Hello!\"\n\n\n\n\n\n\nIf any of the run commands execute with a non-zero exit code, Tusk will\nimmediately exit with the same exit code without executing any other commands.\n\n\nFor executing shell commands, the interpreter used will be the value of the\n\nSHELL\n environment variable. If no environment variable is set, the default is\n\nsh\n.\n\n\nSet Environment\n\n\nThe second type of action a \nrun\n clause can perform is setting or unsetting\nenvironment variables. To do so, simply define a map of environment variable\nnames to their desired values:\n\n\ntasks\n:\n\n  \nhello\n:\n\n    \noptions\n:\n\n      \nproxy-url\n:\n\n        \ndefault\n:\n \nhttp://proxy.example.com\n\n    \nrun\n:\n\n      \n-\n \nset-environment\n:\n\n          \nhttp_proxy\n:\n \n${proxy-url}\n\n          \nhttps_proxy\n:\n \n${proxy-url}\n\n          \nno_proxy\n:\n \n~\n\n      \n-\n \ncommand\n:\n \ncurl http://example.com\n\n\n\n\n\n\nPassing \n~\n or \nnull\n to an environment variable will explicitly unset it, while\npassing an empty string will set it to an empty string.\n\n\nSub-Tasks\n\n\nRun can also execute previously-defined tasks:\n\n\ntasks\n:\n\n  \none\n:\n\n    \nrun\n:\n \necho \"Inside one\"\n\n  \ntwo\n:\n\n    \nrun\n:\n\n      \n-\n \ntask\n:\n \none\n\n      \n-\n \ncommand\n:\n \necho \"Inside two\"\n\n\n\n\n\n\nFor any option that a sub-task defines, the parent task can pass a value, which\nis treated the same way as passing by command-line would be. To do so, use the\nlong definition of a sub-task:\n\n\ntasks\n:\n\n  \ngreet\n:\n\n    \noptions\n:\n\n      \nperson\n:\n\n        \ndefault\n:\n \nWorld\n\n    \nrun\n:\n \necho \"Hello, ${person}!\"\n\n  \ngreet-myself\n:\n\n    \nrun\n:\n\n      \ntask\n:\n\n        \nname\n:\n \ngreet\n\n        \noptions\n:\n\n          \nperson\n:\n \nme\n\n\n\n\n\n\nIn cases where a sub-task may not be useful on its own, define it as private to\nprevent it from being invoked directly from the command-line. For example:\n\n\ntasks\n:\n\n  \nconfigure-environment\n:\n\n    \nprivate\n:\n \ntrue\n\n    \nrun\n:\n\n      \nset-environment\n:\n \n{\nAPP_ENV\n:\n \ndev\n}\n\n  \nserve\n:\n\n    \nrun\n:\n\n      \n-\n \ntask\n:\n \nconfigure-environment\n\n      \n-\n \ncommand\n:\n \npython main.py\n\n\n\n\n\n\nWhen\n\n\nFor conditional execution, \nwhen\n clauses are available.\n\n\nrun\n:\n\n  \nwhen\n:\n\n    \nos\n:\n \nlinux\n\n  \ncommand\n:\n \necho \"This is a linux machine\"\n\n\n\n\n\n\nIn a \nrun\n clause, any item with a true \nwhen\n clause will execute. There are\nfive different checks supported:\n\n\n\n\ncommand\n (string): Execute if the command runs with an exit code of \n0\n.\n\n\nexists\n (string): Execute if the file exists.\n\n\nos\n (list): Execute if the operating system matches any one from the list.\n\n\nenvironment\n (map[string -> string]): Execute if the environment variable\n  matches the value it maps to. To check if a variable is not set, the value\n  should be \n~\n or \nnull\n.\n\n\nequal\n (map[string -> string]): Execute if the given option equals the value\n  it maps to.\n\n\nnot-equal\n (map[string -> string]): Execute if the given option does not\n  equal the value it maps to.\n\n\n\n\nThe \nwhen\n clause supports any number of different checks as a list, where each\ncheck must pass individually for the clause to evaluate to true. Here is a more\ncomplicated example of how \nwhen\n can be used:\n\n\ntasks\n:\n\n  \necho\n:\n\n    \noptions\n:\n\n      \ncat\n:\n\n        \nusage\n:\n \nCat a file\n\n    \nrun\n:\n\n      \n-\n \nwhen\n:\n\n          \nos\n:\n\n            \n-\n \nlinux\n\n            \n-\n \ndarwin\n\n        \ncommand\n:\n \necho \"This is a unix machine\"\n\n      \n-\n \nwhen\n:\n\n          \n-\n \nexists\n:\n \nmy_file.txt\n\n          \n-\n \nequal\n:\n \n{\ncat\n:\n \ntrue\n}\n\n          \n-\n \ncommand\n:\n \ncommand -v cat\n\n        \ncommand\n:\n \ncat my_file.txt\n\n\n\n\n\n\nOptions\n\n\nTasks may have options that are passed as GNU-style flags. The following\nconfiguration will provide \n-n, --name\n flags to the CLI and help documentation,\nwhich will then be interpolated:\n\n\ntasks\n:\n\n  \ngreet\n:\n\n    \noptions\n:\n\n      \nname\n:\n\n        \nusage\n:\n \nThe person to greet\n\n        \nshort\n:\n \nn\n\n        \nenvironment\n:\n \nGREET_NAME\n\n        \ndefault\n:\n \nWorld\n\n    \nrun\n:\n \necho \"Hello, ${name}!\"\n\n\n\n\n\n\nThe above configuration will evaluate the value of \nname\n in order of highest\npriority:\n\n\n\n\nThe value passed by command line flags (\n-n\n or \n--name\n)\n\n\nThe value of the environment variable (\nGREET_NAME\n), if set\n\n\nThe value set in default\n\n\n\n\nOption Types\n\n\nOptions can be of the types \nstring\n, \ninteger\n, \nfloat\n, or \nboolean\n, using\nthe zero-value of that type as the default if not set. Options without types\nspecified are considered strings.\n\n\nFor boolean values, the flag should be passed by command line without any\narugments. In the following example:\n\n\ntasks\n:\n\n  \ngreet\n:\n\n    \noptions\n:\n\n      \nloud\n:\n\n        \ntype\n:\n \nbool\n\n    \nrun\n:\n\n      \n-\n \nwhen\n:\n\n          \nequal\n:\n \n{\nloud\n:\n \ntrue\n}\n\n        \ncommand\n:\n \necho \"HELLO!\"\n\n      \n-\n \nwhen\n:\n\n          \nequal\n:\n \n{\nloud\n:\n \nfalse\n}\n\n        \ncommand\n:\n \necho \"Hello.\"\n\n\n\n\n\n\nThe flag should be passed as such:\n\n\ntusk greet --loud\n\n\n\n\n\nThis means that for an option that is true by default, the only way to disable\nit is with the following syntax:\n\n\ntusk greet --loud\n=\nfalse\n\n\n\n\n\n\nOf course, options can always be defined in the reverse manner to avoid this\nissue:\n\n\noptions\n:\n\n  \nno-loud\n:\n\n    \ntype\n:\n \nbool\n\n\n\n\n\n\nOption Defaults\n\n\nMuch like \nrun\n clauses accept a shorthand form, passing a string to \ndefault\n\nis shorthand. The following options are exactly equivalent:\n\n\noptions\n:\n\n  \nshort\n:\n\n    \ndefault\n:\n \nfoo\n\n  \nlong\n:\n\n    \ndefault\n:\n\n      \n-\n \nvalue\n:\n \nfoo\n\n\n\n\n\n\nA \ndefault\n clause can also register the \nstdout\n of a command as its value:\n\n\noptions\n:\n\n  \nos\n:\n\n    \ndefault\n:\n\n      \ncommand\n:\n \nuname -s\n\n\n\n\n\n\nA \ndefault\n clause also accepts a list of possible values with a corresponding\n\nwhen\n clause. The first \nwhen\n that evaluates to true will be used as the\ndefault value, with an omitted \nwhen\n always considered true.\n\n\nIn this example, linux users will have the name \nLinux User\n, while the default\nfor all other OSes is \nUser\n:\n\n\noptions\n:\n\n  \nname\n:\n\n    \ndefault\n:\n\n      \n-\n \nwhen\n:\n\n          \nos\n:\n \nlinux\n\n        \nvalue\n:\n \nLinux User\n\n      \n-\n \nvalue\n:\n \nUser\n\n\n\n\n\n\nOption Values\n\n\nAn option can specify which values are considered valid:\n\n\noptions\n:\n\n  \nnumber\n:\n\n    \ndefault\n:\n \nzero\n\n    \nvalues\n:\n\n      \n-\n \none\n\n      \n-\n \ntwo\n\n      \n-\n \nthree\n\n\n\n\n\n\nAny value passed by command-line flags or environment variables must be one of\nthe listed values. Default values, including commands, are excluded from this\nrequirement.\n\n\nRequired Options\n\n\nOptions may be required if there is no sane default value. For a required flag,\nthe task will not execute unless the flag is passed:\n\n\noptions\n:\n\n  \nfile\n:\n\n    \nrequired\n:\n \ntrue\n\n\n\n\n\n\nA required option cannot be private or have any default values.\n\n\nPrivate Options\n\n\nSometimes it may be desirable to have a variable that cannot be directly\nmodified through command-line flags. In this case, use the \nprivate\n option:\n\n\noptions\n:\n\n  \nuser\n:\n\n    \nprivate\n:\n \ntrue\n\n    \ndefault\n:\n\n      \ncommand\n:\n \nwhoami\n\n\n\n\n\n\nA private option will not accept environment variables or command line flags,\nand it will not appear in the help documentation.\n\n\nShared Options\n\n\nOptions may also be defined at the root of the config file to be shared between\ntasks:\n\n\noptions\n:\n\n  \nname\n:\n\n    \nusage\n:\n \nThe person to greet\n\n    \ndefault\n:\n \nWorld\n\n\n\ntasks\n:\n\n  \nhello\n:\n\n    \nrun\n:\n \necho \"Hello, ${name}!\"\n\n  \ngoodbye\n:\n\n    \nrun\n:\n \necho \"Goodbye, ${name}!\"\n\n\n\n\n\n\nAny shared variables referenced by a task will be exposed by command-line when\ninvoking that task. Shared variables referenced by a sub-task will be evaluated\nas needed, but not exposed by command-line.\n\n\nCLI Metadata\n\n\nIt is also possible to create a custom CLI tool for use outside of a project's\ndirectory by using shell aliases:\n\n\nalias\n \nmycli\n=\n\"tusk -f /path/to/tusk.yml\"\n\n\n\n\n\n\nIn that case, it may be useful to override the tool name and usage text that\nare provided as part of the help documentation:\n\n\nname\n:\n \nmycli\n\n\nusage\n:\n \nA custom aliased command-line application\n\n\n\ntasks\n:\n\n  \n...\n\n\n\n\n\n\nThe example above will produce the following help documentation:\n\n\nmycli - A custom aliased command-line application\n\nUsage:\n  mycli [global options] <task> [task options]\n\nTasks:\n  ...\n\n\n\n\n\nInterpolation\n\n\nThe interpolation syntax for a variable \nfoo\n is \n${foo}\n, meaning any instances\nof \n${foo}\n in the configuration file will be replaced with the value of \nfoo\n\nduring execution.\n\n\nInterpolation is done on a task-by-task basis, meaning options defined in one\ntask will not interpolate to any other tasks. For each task, interpolation is\ndone iteratively in the order that variables are defined, with shared variables\nbeing evaluated first. This means that options can reference other options:\n\n\noptions\n:\n\n  \nname\n:\n\n    \ndefault\n:\n \nWorld\n\n  \ngreeting\n:\n\n    \ndefault\n:\n \nHello, ${name}\n\n\n\ntasks\n:\n\n  \ngreet\n:\n\n    \nrun\n:\n \necho \"${greeting}\"\n\n\n\n\n\n\nBecause interpolation is not always desirable, as in the case of environment\nvariables, \n$$\n will escape to \n$\n and ignore interpolation. It is also\npossible to use alternative syntax such as \n$foo\n to avoid interpolation as\nwell. The following two tasks will both use environment variables and not\nattempt interpolation:\n\n\ntasks\n:\n\n  \none\n:\n\n    \nrun\n:\n \nHello, $${USER}\n\n  \ntwo\n:\n\n    \nrun\n:\n \nHello, $USER\n\n\n\n\n\n\nInterpolation works by substituting the value in the \nyaml\n config file, then\nparsing the file after interpolation. This means that variable values with\nnewlines or other characters that are relevant to the \nyaml\n spec or the \nsh\n\ninterpreter will need to be considered by the user. This can be as simple as\nusing quotes when appropriate.",
            "title": "The Spec"
        },
        {
            "location": "/spec/#the-spec",
            "text": "",
            "title": "The Spec"
        },
        {
            "location": "/spec/#tasks",
            "text": "The core of every  tusk.yml  file is a list of tasks. Tasks are declared at the\ntop level of the  tusk.yml  file and include a list of tasks.  For the following tasks:  tasks : \n   hello : \n     run :   echo \"Hello, world!\" \n   goodbye : \n     run :   echo \"Goodbye, world!\"   The commands can be run with no additional configuration:  $ tusk hello\nRunning: echo \"Hello, world!\"\nHello, world!  Tasks can be documented with a one-line  usage  string and a slightly longer description . This information will be displayed in help messages:  tasks : \n   hello : \n     usage :   Say hello to the world \n     description :   | \n       This command will echo \"Hello, world!\" to the user. There's no \n       surprises here. \n     run :   echo \"Hello, world!\" \n   goodbye : \n     run :   echo \"Goodbye, world!\"",
            "title": "Tasks"
        },
        {
            "location": "/spec/#run",
            "text": "The behavior of a task is defined in its  run  clause. A  run  clause can be\nused for commands, sub-tasks, or setting environment variables. Although each run  item can only perform one of these actions, they can be run in succession\nto handle complex scenarios.",
            "title": "Run"
        },
        {
            "location": "/spec/#command",
            "text": "In its simplest form,  run  can be given a string or list of strings to be\nexecuted serially as shell commands:  tasks : \n   hello : \n     run :   echo \"Hello!\"   This is a shorthand syntax for the following:  tasks : \n   hello : \n     run : \n       -   command :   echo \"Hello!\"   If any of the run commands execute with a non-zero exit code, Tusk will\nimmediately exit with the same exit code without executing any other commands.  For executing shell commands, the interpreter used will be the value of the SHELL  environment variable. If no environment variable is set, the default is sh .",
            "title": "Command"
        },
        {
            "location": "/spec/#set-environment",
            "text": "The second type of action a  run  clause can perform is setting or unsetting\nenvironment variables. To do so, simply define a map of environment variable\nnames to their desired values:  tasks : \n   hello : \n     options : \n       proxy-url : \n         default :   http://proxy.example.com \n     run : \n       -   set-environment : \n           http_proxy :   ${proxy-url} \n           https_proxy :   ${proxy-url} \n           no_proxy :   ~ \n       -   command :   curl http://example.com   Passing  ~  or  null  to an environment variable will explicitly unset it, while\npassing an empty string will set it to an empty string.",
            "title": "Set Environment"
        },
        {
            "location": "/spec/#sub-tasks",
            "text": "Run can also execute previously-defined tasks:  tasks : \n   one : \n     run :   echo \"Inside one\" \n   two : \n     run : \n       -   task :   one \n       -   command :   echo \"Inside two\"   For any option that a sub-task defines, the parent task can pass a value, which\nis treated the same way as passing by command-line would be. To do so, use the\nlong definition of a sub-task:  tasks : \n   greet : \n     options : \n       person : \n         default :   World \n     run :   echo \"Hello, ${person}!\" \n   greet-myself : \n     run : \n       task : \n         name :   greet \n         options : \n           person :   me   In cases where a sub-task may not be useful on its own, define it as private to\nprevent it from being invoked directly from the command-line. For example:  tasks : \n   configure-environment : \n     private :   true \n     run : \n       set-environment :   { APP_ENV :   dev } \n   serve : \n     run : \n       -   task :   configure-environment \n       -   command :   python main.py",
            "title": "Sub-Tasks"
        },
        {
            "location": "/spec/#when",
            "text": "For conditional execution,  when  clauses are available.  run : \n   when : \n     os :   linux \n   command :   echo \"This is a linux machine\"   In a  run  clause, any item with a true  when  clause will execute. There are\nfive different checks supported:   command  (string): Execute if the command runs with an exit code of  0 .  exists  (string): Execute if the file exists.  os  (list): Execute if the operating system matches any one from the list.  environment  (map[string -> string]): Execute if the environment variable\n  matches the value it maps to. To check if a variable is not set, the value\n  should be  ~  or  null .  equal  (map[string -> string]): Execute if the given option equals the value\n  it maps to.  not-equal  (map[string -> string]): Execute if the given option does not\n  equal the value it maps to.   The  when  clause supports any number of different checks as a list, where each\ncheck must pass individually for the clause to evaluate to true. Here is a more\ncomplicated example of how  when  can be used:  tasks : \n   echo : \n     options : \n       cat : \n         usage :   Cat a file \n     run : \n       -   when : \n           os : \n             -   linux \n             -   darwin \n         command :   echo \"This is a unix machine\" \n       -   when : \n           -   exists :   my_file.txt \n           -   equal :   { cat :   true } \n           -   command :   command -v cat \n         command :   cat my_file.txt",
            "title": "When"
        },
        {
            "location": "/spec/#options",
            "text": "Tasks may have options that are passed as GNU-style flags. The following\nconfiguration will provide  -n, --name  flags to the CLI and help documentation,\nwhich will then be interpolated:  tasks : \n   greet : \n     options : \n       name : \n         usage :   The person to greet \n         short :   n \n         environment :   GREET_NAME \n         default :   World \n     run :   echo \"Hello, ${name}!\"   The above configuration will evaluate the value of  name  in order of highest\npriority:   The value passed by command line flags ( -n  or  --name )  The value of the environment variable ( GREET_NAME ), if set  The value set in default",
            "title": "Options"
        },
        {
            "location": "/spec/#option-types",
            "text": "Options can be of the types  string ,  integer ,  float , or  boolean , using\nthe zero-value of that type as the default if not set. Options without types\nspecified are considered strings.  For boolean values, the flag should be passed by command line without any\narugments. In the following example:  tasks : \n   greet : \n     options : \n       loud : \n         type :   bool \n     run : \n       -   when : \n           equal :   { loud :   true } \n         command :   echo \"HELLO!\" \n       -   when : \n           equal :   { loud :   false } \n         command :   echo \"Hello.\"   The flag should be passed as such:  tusk greet --loud  This means that for an option that is true by default, the only way to disable\nit is with the following syntax:  tusk greet --loud = false   Of course, options can always be defined in the reverse manner to avoid this\nissue:  options : \n   no-loud : \n     type :   bool",
            "title": "Option Types"
        },
        {
            "location": "/spec/#option-defaults",
            "text": "Much like  run  clauses accept a shorthand form, passing a string to  default \nis shorthand. The following options are exactly equivalent:  options : \n   short : \n     default :   foo \n   long : \n     default : \n       -   value :   foo   A  default  clause can also register the  stdout  of a command as its value:  options : \n   os : \n     default : \n       command :   uname -s   A  default  clause also accepts a list of possible values with a corresponding when  clause. The first  when  that evaluates to true will be used as the\ndefault value, with an omitted  when  always considered true.  In this example, linux users will have the name  Linux User , while the default\nfor all other OSes is  User :  options : \n   name : \n     default : \n       -   when : \n           os :   linux \n         value :   Linux User \n       -   value :   User",
            "title": "Option Defaults"
        },
        {
            "location": "/spec/#option-values",
            "text": "An option can specify which values are considered valid:  options : \n   number : \n     default :   zero \n     values : \n       -   one \n       -   two \n       -   three   Any value passed by command-line flags or environment variables must be one of\nthe listed values. Default values, including commands, are excluded from this\nrequirement.",
            "title": "Option Values"
        },
        {
            "location": "/spec/#required-options",
            "text": "Options may be required if there is no sane default value. For a required flag,\nthe task will not execute unless the flag is passed:  options : \n   file : \n     required :   true   A required option cannot be private or have any default values.",
            "title": "Required Options"
        },
        {
            "location": "/spec/#private-options",
            "text": "Sometimes it may be desirable to have a variable that cannot be directly\nmodified through command-line flags. In this case, use the  private  option:  options : \n   user : \n     private :   true \n     default : \n       command :   whoami   A private option will not accept environment variables or command line flags,\nand it will not appear in the help documentation.",
            "title": "Private Options"
        },
        {
            "location": "/spec/#shared-options",
            "text": "Options may also be defined at the root of the config file to be shared between\ntasks:  options : \n   name : \n     usage :   The person to greet \n     default :   World  tasks : \n   hello : \n     run :   echo \"Hello, ${name}!\" \n   goodbye : \n     run :   echo \"Goodbye, ${name}!\"   Any shared variables referenced by a task will be exposed by command-line when\ninvoking that task. Shared variables referenced by a sub-task will be evaluated\nas needed, but not exposed by command-line.",
            "title": "Shared Options"
        },
        {
            "location": "/spec/#cli-metadata",
            "text": "It is also possible to create a custom CLI tool for use outside of a project's\ndirectory by using shell aliases:  alias   mycli = \"tusk -f /path/to/tusk.yml\"   In that case, it may be useful to override the tool name and usage text that\nare provided as part of the help documentation:  name :   mycli  usage :   A custom aliased command-line application  tasks : \n   ...   The example above will produce the following help documentation:  mycli - A custom aliased command-line application\n\nUsage:\n  mycli [global options] <task> [task options]\n\nTasks:\n  ...",
            "title": "CLI Metadata"
        },
        {
            "location": "/spec/#interpolation",
            "text": "The interpolation syntax for a variable  foo  is  ${foo} , meaning any instances\nof  ${foo}  in the configuration file will be replaced with the value of  foo \nduring execution.  Interpolation is done on a task-by-task basis, meaning options defined in one\ntask will not interpolate to any other tasks. For each task, interpolation is\ndone iteratively in the order that variables are defined, with shared variables\nbeing evaluated first. This means that options can reference other options:  options : \n   name : \n     default :   World \n   greeting : \n     default :   Hello, ${name}  tasks : \n   greet : \n     run :   echo \"${greeting}\"   Because interpolation is not always desirable, as in the case of environment\nvariables,  $$  will escape to  $  and ignore interpolation. It is also\npossible to use alternative syntax such as  $foo  to avoid interpolation as\nwell. The following two tasks will both use environment variables and not\nattempt interpolation:  tasks : \n   one : \n     run :   Hello, $${USER} \n   two : \n     run :   Hello, $USER   Interpolation works by substituting the value in the  yaml  config file, then\nparsing the file after interpolation. This means that variable values with\nnewlines or other characters that are relevant to the  yaml  spec or the  sh \ninterpreter will need to be considered by the user. This can be as simple as\nusing quotes when appropriate.",
            "title": "Interpolation"
        }
    ]
}